[上一篇](017-goroutine.md) 讲到了原子函数和互斥锁来保证共享数据的读写,但我们还可以通过 **通道** 在多个 goroutine 发送和接受共享数据, 达到数据同步的目的 

```go
ch := make(chan int)  // 关键字 chan 表明这是个通道变量, 通道中发送和接收数据类型是 int 
ch <- 2  // 发送数值 2 给这个通道 
x := <- ch  // 从通道中读取值并赋给 x 变量 
<- ch  // 从通道中读取值,然后忽略  
close(ch)  // 如果一个通道被关闭了,我们就不能往这个通道里发送数据了,如果发送的话,会引起painc异常。但是我们还可以接收通道里的数据,如果通道里没有数据的话,接收的数据是nil。
```

* 无缓冲通道

  > 发送跟接收必须是同步的, 如果没有同时准备好,先执行的操作就会被阻塞,直到另一个操作准备好为止

  ```go
  func main() {
  	ch := make(chan int)
  	go func() {
  		var sum int = 0
  		for i := 0; i < 10; i++ {
  			sum += i
  		}
  		ch <- sum
  	}()
  	fmt.Println(<-ch)
  } //以前为防止程序提前终止,使用 sync.WaitGroup 进行等待,现在不用了,使用同步通道来等待
  ```

* 有缓冲通道 

  > 向其发送操作相当于向队列尾部插入元素,接收操作则相当于从队列删除元素,并返回刚删除的元素,当队列满了发送会阻塞,当队列空了接受会阻塞

  ```go
  ch := make(chan int 5)  // 缓冲大小为5的有缓冲通道 
  cap(ch) // 获得 ch 的最大容量 
  len(ch) // 获得 ch 的元素个数 
  ```

* 单向通道 

  > 限制一个通道只可以接收不能发送或者只能发送不能接收 

  ```go
  var send chan<- int // 定义一个只能发送的通道 
  var receive <-chan int // 定义一个只能接收的通道  
  ```

  ​